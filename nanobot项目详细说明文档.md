# nanobot é¡¹ç›®è¯¦ç»†è¯´æ˜æ–‡æ¡£

## é¡¹ç›®æ¦‚è¿°

**nanobot** æ˜¯ä¸€ä¸ªè¶…è½»é‡çº§çš„ä¸ªäººAIåŠ©æ‰‹æ¡†æ¶ï¼Œä»…ç”¨çº¦4,000è¡Œä»£ç å®ç°æ ¸å¿ƒåŠŸèƒ½ï¼Œæ¯”åŒç±»é¡¹ç›®Clawdbotå°99%ã€‚å®ƒä¸“ä¸ºç ”ç©¶å’Œå¿«é€Ÿå¼€å‘è€Œè®¾è®¡ï¼Œæä¾›æ¸…æ™°æ˜“æ‡‚çš„ä»£ç ç»“æ„å’Œå¼ºå¤§çš„æ‰©å±•èƒ½åŠ›ã€‚

### æ ¸å¿ƒç‰¹ç‚¹
- ğŸª¶ **è¶…è½»é‡çº§**ï¼šæ ¸å¿ƒåŠŸèƒ½ç²¾ç®€ï¼Œå¯åŠ¨å¿«é€Ÿ
- ğŸ”¬ **ç ”ç©¶å‹å¥½**ï¼šä»£ç æ¸…æ™°ï¼Œæ˜“äºç†è§£å’Œä¿®æ”¹
- âš¡ï¸ **é«˜æ€§èƒ½**ï¼šèµ„æºå ç”¨å°‘ï¼Œå“åº”è¿…é€Ÿ
- ğŸ’ **æ˜“äºä½¿ç”¨**ï¼šä¸€é”®éƒ¨ç½²ï¼Œé…ç½®ç®€å•
- ğŸ”§ **é«˜åº¦å¯æ‰©å±•**ï¼šæ¨¡å—åŒ–è®¾è®¡ï¼Œæ”¯æŒè‡ªå®šä¹‰å·¥å…·å’ŒæŠ€èƒ½

### ä¸»è¦åŠŸèƒ½
- 24/7å®æ—¶å¸‚åœºåˆ†æå’Œä¿¡æ¯æœç´¢
- å…¨æ ˆè½¯ä»¶å·¥ç¨‹å¸ˆåŠ©æ‰‹ï¼ˆä»£ç ç”Ÿæˆã€è°ƒè¯•ã€éƒ¨ç½²ï¼‰
- æ™ºèƒ½æ—¥ç¨‹ç®¡ç†å’Œå®šæ—¶ä»»åŠ¡
- ä¸ªäººçŸ¥è¯†åŠ©æ‰‹å’Œè®°å¿†ç³»ç»Ÿ
- å¤šå¹³å°èŠå¤©é›†æˆï¼ˆTelegramã€WhatsAppï¼‰

---

## ç³»ç»Ÿæ¶æ„

### æ•´ä½“æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Chat Channels                             â”‚
â”‚  (Telegram, WhatsApp, CLI, Discordç­‰)                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚ InboundMessage
                     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Message Bus                                â”‚
â”‚  (Async Queue - è§£è€¦é¢‘é“å’Œä»£ç†)                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚ consume_inbound()
                     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Agent Loop                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ 1. æ¥æ”¶æ¶ˆæ¯                                          â”‚   â”‚
â”‚  â”‚ 2. æ„å»ºä¸Šä¸‹æ–‡ (Context Builder)                      â”‚   â”‚
â”‚  â”‚    - Bootstrapæ–‡ä»¶ (AGENTS.md, SOUL.mdç­‰)           â”‚   â”‚
â”‚  â”‚    - è®°å¿† (MEMORY.md + æ—¥è®°)                        â”‚   â”‚
â”‚  â”‚    - æŠ€èƒ½ (Skills)                                  â”‚   â”‚
â”‚  â”‚    - å¯¹è¯å†å² (Session)                             â”‚   â”‚
â”‚  â”‚ 3. è°ƒç”¨LLM (Provider)                               â”‚   â”‚
â”‚  â”‚ 4. æ‰§è¡Œå·¥å…· (Tool Registry)                         â”‚   â”‚
â”‚  â”‚    - æ–‡ä»¶æ“ä½œ                                       â”‚   â”‚
â”‚  â”‚    - Shellå‘½ä»¤                                      â”‚   â”‚
â”‚  â”‚    - Webæœç´¢/è·å–                                   â”‚   â”‚
â”‚  â”‚    - æ¶ˆæ¯å‘é€                                       â”‚   â”‚
â”‚  â”‚    - å­ä»£ç†ç”Ÿæˆ                                     â”‚   â”‚
â”‚  â”‚ 5. å¾ªç¯ç›´åˆ°å®Œæˆ (max 20æ¬¡è¿­ä»£)                      â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚ OutboundMessage
                     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Message Bus                                â”‚
â”‚  (dispatch_outbound - åˆ†å‘åˆ°è®¢é˜…çš„é¢‘é“)                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚ publish_outbound()
                     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Chat Channels                             â”‚
â”‚  (å‘é€å“åº”ç»™ç”¨æˆ·)                                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Background Services                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚ Cron Service â”‚  â”‚Heartbeat Svc â”‚  â”‚ Subagent Mgr â”‚      â”‚
â”‚  â”‚ (å®šæ—¶ä»»åŠ¡)   â”‚  â”‚ (30åˆ†é’Ÿæ£€æŸ¥) â”‚  â”‚ (åå°ä»»åŠ¡)   â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ ¸å¿ƒè®¾è®¡åŸåˆ™

1. **è§£è€¦æ¶æ„**ï¼šæ¶ˆæ¯æ€»çº¿å®Œå…¨è§£è€¦é¢‘é“å’Œä»£ç†æ ¸å¿ƒ
2. **å¼‚æ­¥å¤„ç†**ï¼šå…¨å¼‚æ­¥è®¾è®¡ï¼Œæ”¯æŒé«˜å¹¶å‘
3. **æ¨¡å—åŒ–**ï¼šæ¯ä¸ªç»„ä»¶èŒè´£å•ä¸€ï¼Œæ˜“äºæµ‹è¯•å’Œç»´æŠ¤
4. **å¯æ‰©å±•æ€§**ï¼šå·¥å…·æ³¨å†Œè¡¨ã€æŠ€èƒ½ç³»ç»Ÿæ”¯æŒåŠ¨æ€æ‰©å±•
5. **å®¹é”™æ€§**ï¼šä¼˜é›…çš„é”™è¯¯å¤„ç†å’Œæ¢å¤æœºåˆ¶

---

## æ ¸å¿ƒæ¨¡å—è¯¦è§£

### 1. Agent æ ¸å¿ƒæ¨¡å— (`nanobot/agent/`)

#### AgentLoop - ä»£ç†ä¸»å¾ªç¯å¼•æ“ (`loop.py`)

**èŒè´£**ï¼š
- æ¥æ”¶å’Œå¤„ç†æ¥è‡ªæ¶ˆæ¯æ€»çº¿çš„æ¶ˆæ¯
- æ„å»ºLLMä¸Šä¸‹æ–‡ï¼ˆç³»ç»Ÿæç¤º + å¯¹è¯å†å²ï¼‰
- è°ƒç”¨LLMå¹¶å¤„ç†å“åº”
- æ‰§è¡Œå·¥å…·è°ƒç”¨ï¼ˆæœ€å¤š20æ¬¡è¿­ä»£ï¼‰
- å‘é€å“åº”åˆ°æ¶ˆæ¯æ€»çº¿

**æ ¸å¿ƒæµç¨‹**ï¼š
```python
async def _process_message(self, msg: InboundMessage) -> None:
    # 1. è·å–æˆ–åˆ›å»ºä¼šè¯
    session = self.sessions.get_or_create(msg.session_key)
    
    # 2. æ„å»ºLLMæ¶ˆæ¯åˆ—è¡¨
    messages = self.context.build_messages(session, msg.content, msg.media)
    
    # 3. å·¥å…·è°ƒç”¨å¾ªç¯
    for iteration in range(self.max_iterations):
        response = await self.provider.chat(
            messages=messages,
            tools=self.tools.get_schemas(),
            model=self.model
        )
        
        if response.tool_calls:
            # æ‰§è¡Œå·¥å…·å¹¶æ·»åŠ ç»“æœåˆ°æ¶ˆæ¯
            for tool_call in response.tool_calls:
                result = await self.tools.execute(tool_call.name, tool_call.arguments)
                messages.append({"role": "tool", "content": result})
        else:
            # æ²¡æœ‰å·¥å…·è°ƒç”¨ï¼Œè¿”å›æœ€ç»ˆå“åº”
            break
    
    # 4. ä¿å­˜ä¼šè¯å¹¶å‘é€å“åº”
    session.add_message("assistant", response.content)
    await self.bus.publish_outbound(OutboundMessage(...))
```

#### ContextBuilder - ä¸Šä¸‹æ–‡æ„å»ºå™¨ (`context.py`)

**èŒè´£**ï¼š
- ç»„è£…ç³»ç»Ÿæç¤ºè¯ï¼ˆBootstrapæ–‡ä»¶ã€è®°å¿†ã€æŠ€èƒ½ï¼‰
- æ„å»ºLLMæ¶ˆæ¯åˆ—è¡¨
- å¤„ç†å¤šæ¨¡æ€è¾“å…¥ï¼ˆæ–‡æœ¬+å›¾åƒï¼‰

**Bootstrapæ–‡ä»¶åŠ è½½é¡ºåº**ï¼š
1. `AGENTS.md` - ä»£ç†æŒ‡ä»¤å’Œè¡Œä¸ºå‡†åˆ™
2. `SOUL.md` - ä»£ç†äººæ ¼å’Œç‰¹æ€§
3. `USER.md` - ç”¨æˆ·ä¿¡æ¯å’Œåå¥½
4. `TOOLS.md` - å·¥å…·ä½¿ç”¨è¯´æ˜
5. `IDENTITY.md` - èº«ä»½è®¤è¯ä¿¡æ¯

**ç³»ç»Ÿæç¤ºæ„å»º**ï¼š
```python
def build_system_prompt(self, skill_names: list[str] | None = None) -> str:
    parts = []
    
    # æ ¸å¿ƒèº«ä»½
    parts.append(self._get_identity())
    
    # Bootstrapæ–‡ä»¶
    bootstrap = self._load_bootstrap_files()
    if bootstrap:
        parts.append(bootstrap)
    
    # è®°å¿†ä¸Šä¸‹æ–‡
    memory = self.memory.get_memory_context()
    if memory:
        parts.append(f"# Memory\n\n{memory}")
    
    # æŠ€èƒ½ç³»ç»Ÿ
    always_skills = self.skills.get_always_skills()
    if always_skills:
        always_content = self.skills.load_skills_for_context(always_skills)
        if always_content:
            parts.append(f"# Active Skills\n\n{always_content}")
    
    return "\n\n".join(parts)
```

#### MemoryStore - æŒä¹…åŒ–è®°å¿†ç³»ç»Ÿ (`memory.py`)

**è®°å¿†ç±»å‹**ï¼š
- **é•¿æœŸè®°å¿†**ï¼š`MEMORY.md` - é‡è¦ä¿¡æ¯å’Œå­¦ä¹ å†…å®¹
- **æ—¥è®°ç¬”è®°**ï¼š`memory/YYYY-MM-DD.md` - æ¯æ—¥æ´»åŠ¨è®°å½•

**è®°å¿†æ£€ç´¢**ï¼š
```python
def get_memory_context(self, days: int = 7) -> str:
    parts = []
    
    # é•¿æœŸè®°å¿†
    long_term = self._load_long_term_memory()
    if long_term:
        parts.append(f"## Long-term Memory\n\n{long_term}")
    
    # æœ€è¿‘Nå¤©çš„æ—¥è®°
    recent_notes = self._load_recent_notes(days)
    if recent_notes:
        parts.append(f"## Recent Notes\n\n{recent_notes}")
    
    return "\n\n".join(parts)
```

#### SkillsLoader - æŠ€èƒ½åŠ è½½å™¨ (`skills.py`)

**æŠ€èƒ½ç±»å‹**ï¼š
- **å†…ç½®æŠ€èƒ½**ï¼š`nanobot/skills/` - æ¡†æ¶æä¾›çš„æ ‡å‡†æŠ€èƒ½
- **å·¥ä½œç©ºé—´æŠ€èƒ½**ï¼š`workspace/skills/` - ç”¨æˆ·è‡ªå®šä¹‰æŠ€èƒ½

**æ¸è¿›å¼åŠ è½½**ï¼š
```python
def build_skills_summary(self) -> str:
    """æ„å»ºæŠ€èƒ½æ‘˜è¦ï¼Œä»£ç†å¯æŒ‰éœ€è¯»å–å®Œæ•´å†…å®¹"""
    all_skills = self.list_skills(filter_unavailable=False)
    
    lines = ["<skills>"]
    for s in all_skills:
        available = self._check_requirements(self._get_skill_meta(s["name"]))
        lines.append(f"  <skill available=\"{str(available).lower()}\">")
        lines.append(f"    <name>{s['name']}</name>")
        lines.append(f"    <description>{self._get_skill_description(s['name'])}</description>")
        lines.append(f"    <location>{s['path']}</location>")
        lines.append(f"  </skill>")
    lines.append("</skills>")
    
    return "\n".join(lines)
```

#### SubagentManager - åå°å­ä»£ç†ç®¡ç† (`subagent.py`)

**åŠŸèƒ½**ï¼š
- ç”Ÿæˆè½»é‡çº§å­ä»£ç†æ‰§è¡Œç‰¹å®šä»»åŠ¡
- ç‹¬ç«‹ä¸Šä¸‹æ–‡å’Œèšç„¦ç³»ç»Ÿæç¤º
- é€šè¿‡æ¶ˆæ¯æ€»çº¿å…¬å‘Šç»“æœ

**å­ä»£ç†æ‰§è¡Œæµç¨‹**ï¼š
```python
async def spawn(self, task: str, label: str | None = None) -> str:
    subagent_id = f"subagent-{uuid.uuid4().hex[:8]}"
    
    # åå°æ‰§è¡Œå­ä»£ç†ä»»åŠ¡
    asyncio.create_task(self._run_subagent(subagent_id, task, label))
    
    return f"Spawned subagent {subagent_id} for: {task}"

async def _run_subagent(self, subagent_id: str, task: str, label: str | None) -> None:
    # æ„å»ºå­ä»£ç†ä¸“ç”¨æç¤º
    system_prompt = self._build_subagent_prompt(task)
    
    # æ‰§è¡Œå·¥å…·å¾ªç¯ï¼ˆæœ€å¤š15æ¬¡è¿­ä»£ï¼‰
    messages = [{"role": "user", "content": task}]
    
    for iteration in range(15):
        response = await self.provider.chat(
            messages=[{"role": "system", "content": system_prompt}] + messages,
            tools=self.tools.get_schemas()
        )
        
        if response.tool_calls:
            # æ‰§è¡Œå·¥å…·è°ƒç”¨
            for tool_call in response.tool_calls:
                result = await self.tools.execute(tool_call.name, tool_call.arguments)
                messages.append({"role": "tool", "content": result})
        else:
            break
    
    # å…¬å‘Šç»“æœåˆ°ä¸»ä»£ç†
    announcement = InboundMessage(
        channel="system",
        sender_id="subagent",
        chat_id=subagent_id,
        content=f"Subagent completed: {response.content}"
    )
    await self.bus.publish_inbound(announcement)
```

### 2. å·¥å…·ç³»ç»Ÿ (`nanobot/agent/tools/`)

#### ToolRegistry - å·¥å…·æ³¨å†Œè¡¨ (`registry.py`)

**åŠŸèƒ½**ï¼š
- åŠ¨æ€æ³¨å†Œå’Œç®¡ç†å·¥å…·
- å‚æ•°éªŒè¯å’Œé”™è¯¯å¤„ç†
- å·¥å…·è°ƒç”¨æ‰§è¡Œ

**æ ¸å¿ƒæ–¹æ³•**ï¼š
```python
class ToolRegistry:
    def register(self, tool: Tool) -> None:
        """æ³¨å†Œå·¥å…·"""
        self._tools[tool.name] = tool
    
    async def execute(self, name: str, arguments: dict[str, Any]) -> str:
        """æ‰§è¡Œå·¥å…·è°ƒç”¨"""
        tool = self._tools.get(name)
        if not tool:
            return f"Error: Unknown tool '{name}'"
        
        # å‚æ•°éªŒè¯
        errors = tool.validate_params(arguments)
        if errors:
            return f"Error: {'; '.join(errors)}"
        
        # æ‰§è¡Œå·¥å…·
        try:
            return await tool.execute(**arguments)
        except Exception as e:
            return f"Error executing {name}: {str(e)}"
    
    def get_schemas(self) -> list[dict[str, Any]]:
        """è·å–æ‰€æœ‰å·¥å…·çš„OpenAIæ ¼å¼schema"""
        return [tool.to_schema() for tool in self._tools.values()]
```

#### å†…ç½®å·¥å…·

**æ–‡ä»¶æ“ä½œå·¥å…·** (`filesystem.py`)ï¼š
- `read_file` - è¯»å–æ–‡ä»¶å†…å®¹
- `write_file` - å†™å…¥æ–‡ä»¶ï¼ˆè‡ªåŠ¨åˆ›å»ºç›®å½•ï¼‰
- `edit_file` - ç¼–è¾‘æ–‡ä»¶ï¼ˆæ›¿æ¢æŒ‡å®šæ–‡æœ¬ï¼‰
- `list_dir` - åˆ—å‡ºç›®å½•å†…å®¹

**Shellæ‰§è¡Œå·¥å…·** (`shell.py`)ï¼š
- `exec` - æ‰§è¡ŒShellå‘½ä»¤
- å®‰å…¨é™åˆ¶ï¼šè¶…æ—¶æ§åˆ¶ã€å±é™©å‘½ä»¤é˜»æ­¢ã€è¾“å‡ºæˆªæ–­
- å¯é€‰å·¥ä½œç©ºé—´é™åˆ¶

**Webè®¿é—®å·¥å…·** (`web.py`)ï¼š
- `web_search` - ä½¿ç”¨Brave Search APIæœç´¢
- `web_fetch` - è·å–ç½‘é¡µå†…å®¹ï¼ˆä½¿ç”¨readabilityæå–ï¼‰

**é€šä¿¡å·¥å…·** (`message.py`)ï¼š
- `message` - å‘é€æ¶ˆæ¯åˆ°æŒ‡å®šé¢‘é“

**å­ä»£ç†å·¥å…·** (`spawn.py`)ï¼š
- `spawn` - ç”Ÿæˆåå°å­ä»£ç†æ‰§è¡Œä»»åŠ¡

### 3. æ¶ˆæ¯æ€»çº¿ (`nanobot/bus/`)

#### MessageBus - å¼‚æ­¥æ¶ˆæ¯é˜Ÿåˆ— (`queue.py`)

**åŠŸèƒ½**ï¼š
- è§£è€¦é¢‘é“å’Œä»£ç†æ ¸å¿ƒ
- å¼‚æ­¥æ¶ˆæ¯ä¼ é€’
- æ”¯æŒè®¢é˜…å’Œåˆ†å‘

**æ¶ˆæ¯æµ**ï¼š
```python
# å…¥ç«™æ¶ˆæ¯ï¼šé¢‘é“ â†’ ä»£ç†
await bus.publish_inbound(InboundMessage(...))
msg = await bus.consume_inbound()

# å‡ºç«™æ¶ˆæ¯ï¼šä»£ç† â†’ é¢‘é“
await bus.publish_outbound(OutboundMessage(...))
msg = await bus.consume_outbound()
```

#### äº‹ä»¶ç±»å‹ (`events.py`)

**InboundMessage** - æ¥è‡ªé¢‘é“çš„æ¶ˆæ¯ï¼š
```python
@dataclass
class InboundMessage:
    channel: str          # telegram, whatsapp, cli
    sender_id: str         # ç”¨æˆ·æ ‡è¯†
    chat_id: str          # èŠå¤©æ ‡è¯†
    content: str          # æ¶ˆæ¯å†…å®¹
    timestamp: datetime   # æ—¶é—´æˆ³
    media: list[str]      # åª’ä½“URLåˆ—è¡¨
    metadata: dict        # é¢‘é“ç‰¹å®šæ•°æ®
```

**OutboundMessage** - å‘é€åˆ°é¢‘é“çš„å“åº”ï¼š
```python
@dataclass
class OutboundMessage:
    channel: str          # ç›®æ ‡é¢‘é“
    chat_id: str         # ç›®æ ‡èŠå¤©
    content: str         # å“åº”å†…å®¹
    reply_to: str | None # å›å¤æ¶ˆæ¯ID
    media: list[str]     # åª’ä½“æ–‡ä»¶
    metadata: dict       # é¢‘é“ç‰¹å®šæ•°æ®
```

### 4. ä¼šè¯ç®¡ç† (`nanobot/session/`)

#### SessionManager - å¯¹è¯ä¼šè¯ç®¡ç† (`manager.py`)

**åŠŸèƒ½**ï¼š
- JSONLæ ¼å¼å­˜å‚¨æ¶ˆæ¯å†å²
- ä¼šè¯ç¼“å­˜å’ŒæŒä¹…åŒ–
- æä¾›LLMæ ¼å¼çš„å†å²è®°å½•

**å­˜å‚¨æ ¼å¼**ï¼š
```jsonl
{"_type": "metadata", "created_at": "2024-01-01T00:00:00", "metadata": {}}
{"role": "user", "content": "Hello", "timestamp": "2024-01-01T00:00:01"}
{"role": "assistant", "content": "Hi there!", "timestamp": "2024-01-01T00:00:02"}
```

**ä¼šè¯æ“ä½œ**ï¼š
```python
# è·å–æˆ–åˆ›å»ºä¼šè¯
session = manager.get_or_create("telegram:123456789")

# æ·»åŠ æ¶ˆæ¯
session.add_message("user", "Hello world")
session.add_message("assistant", "Hi there!")

# è·å–å†å²è®°å½•ï¼ˆLLMæ ¼å¼ï¼‰
history = session.get_history(max_messages=50)

# ä¿å­˜åˆ°ç£ç›˜
manager.save(session)
```

### 5. LLMæä¾›å•† (`nanobot/providers/`)

#### LiteLLMProvider - å¤šæä¾›å•†æ”¯æŒ (`litellm_provider.py`)

**æ”¯æŒçš„æä¾›å•†**ï¼š
- OpenRouterï¼ˆæ¨èï¼‰
- Anthropic (Claude)
- OpenAI (GPT)
- Google Gemini
- Groq
- æ™ºè°±AI (GLM)
- vLLMï¼ˆæœ¬åœ°éƒ¨ç½²ï¼‰

**è‡ªåŠ¨é…ç½®**ï¼š
```python
def __init__(self, api_key: str, api_base: str | None = None, default_model: str = "anthropic/claude-opus-4-5"):
    # æ ¹æ®APIå¯†é’¥å‰ç¼€æˆ–æ¨¡å‹åç§°è‡ªåŠ¨æ£€æµ‹æä¾›å•†
    if api_key.startswith("sk-or-"):
        # OpenRouter
        os.environ["OPENROUTER_API_KEY"] = api_key
    elif "anthropic" in default_model:
        os.environ["ANTHROPIC_API_KEY"] = api_key
    elif "openai" in default_model or "gpt" in default_model:
        os.environ["OPENAI_API_KEY"] = api_key
    # ... å…¶ä»–æä¾›å•†
```

**ç»Ÿä¸€æ¥å£**ï¼š
```python
async def chat(
    self,
    messages: list[dict[str, Any]],
    tools: list[dict[str, Any]] | None = None,
    model: str | None = None,
    max_tokens: int = 4096,
    temperature: float = 0.7,
) -> LLMResponse:
    # é€šè¿‡LiteLLMè°ƒç”¨å„ç§æä¾›å•†
    response = await acompletion(
        model=model or self.default_model,
        messages=messages,
        tools=tools,
        max_tokens=max_tokens,
        temperature=temperature
    )
    return self._parse_response(response)
```

### 6. é¢‘é“é›†æˆ (`nanobot/channels/`)

#### ChannelManager - é¢‘é“ç®¡ç†å™¨ (`manager.py`)

**åŠŸèƒ½**ï¼š
- åˆå§‹åŒ–å¯ç”¨çš„é¢‘é“
- å¯åŠ¨/åœæ­¢é¢‘é“æœåŠ¡
- è·¯ç”±å‡ºç«™æ¶ˆæ¯åˆ°å¯¹åº”é¢‘é“

**é¢‘é“ç”Ÿå‘½å‘¨æœŸ**ï¼š
```python
async def start_all(self) -> None:
    # å¯åŠ¨å‡ºç«™æ¶ˆæ¯åˆ†å‘å™¨
    self._dispatch_task = asyncio.create_task(self._dispatch_outbound())
    
    # å¯åŠ¨æ‰€æœ‰é¢‘é“
    tasks = []
    for name, channel in self.channels.items():
        tasks.append(asyncio.create_task(channel.start()))
    
    await asyncio.gather(*tasks, return_exceptions=True)

async def _dispatch_outbound(self) -> None:
    """åˆ†å‘å‡ºç«™æ¶ˆæ¯åˆ°å¯¹åº”é¢‘é“"""
    while True:
        msg = await self.bus.consume_outbound()
        channel = self.channels.get(msg.channel)
        if channel:
            await channel.send(msg)
```

#### Telegramé›†æˆ (`telegram.py`)

**åŠŸèƒ½**ï¼š
- ä½¿ç”¨python-telegram-botåº“
- æ”¯æŒæ–‡æœ¬ã€å›¾ç‰‡ã€è¯­éŸ³æ¶ˆæ¯
- ç”¨æˆ·ç™½åå•æ§åˆ¶
- è¯­éŸ³è½¬æ–‡å­—ï¼ˆå¯é€‰Groq Whisperï¼‰

#### WhatsAppé›†æˆ (`whatsapp.py`)

**åŠŸèƒ½**ï¼š
- é€šè¿‡Node.jsæ¡¥æ¥æœåŠ¡è¿æ¥
- WebSocketé€šä¿¡
- æ”¯æŒæ–‡æœ¬å’Œåª’ä½“æ¶ˆæ¯
- æ‰«ç ç™»å½•

### 7. å®šæ—¶ä»»åŠ¡ç³»ç»Ÿ (`nanobot/cron/`)

#### CronService - å®šæ—¶ä»»åŠ¡æœåŠ¡ (`service.py`)

**æ”¯æŒçš„è°ƒåº¦ç±»å‹**ï¼š
- **ä¸€æ¬¡æ€§ä»»åŠ¡**ï¼š`at` - æŒ‡å®šæ—¶é—´æ‰§è¡Œ
- **å‘¨æœŸæ€§ä»»åŠ¡**ï¼š`every` - å›ºå®šé—´éš”æ‰§è¡Œ
- **Cronè¡¨è¾¾å¼**ï¼š`cron` - å¤æ‚æ—¶é—´è§„åˆ™

**ä»»åŠ¡æ‰§è¡Œæµç¨‹**ï¼š
```python
async def _execute_job(self, job: CronJob) -> None:
    """æ‰§è¡Œå•ä¸ªä»»åŠ¡"""
    try:
        # è°ƒç”¨ä»£ç†å¤„ç†ä»»åŠ¡æ¶ˆæ¯
        response = await self.on_job(job)
        
        job.state.last_status = "ok"
        
        # å¯é€‰ï¼šæŠ•é€’ç»“æœåˆ°æŒ‡å®šé¢‘é“
        if job.payload.deliver and job.payload.channel:
            await self._deliver_response(job, response)
            
    except Exception as e:
        job.state.last_status = "error"
        job.state.last_error = str(e)
    
    # è®¡ç®—ä¸‹æ¬¡æ‰§è¡Œæ—¶é—´
    job.state.next_run_at_ms = _compute_next_run(job.schedule, _now_ms())
```

**CLIæ“ä½œ**ï¼š
```bash
# æ·»åŠ å®šæ—¶ä»»åŠ¡
nanobot cron add --name "daily-report" --message "Generate daily report" --cron "0 9 * * *"

# åˆ—å‡ºä»»åŠ¡
nanobot cron list

# åˆ é™¤ä»»åŠ¡
nanobot cron remove <job_id>
```

### 8. å¿ƒè·³æœåŠ¡ (`nanobot/heartbeat/`)

#### HeartbeatService - å‘¨æœŸæ€§ä»»åŠ¡æ£€æŸ¥ (`service.py`)

**åŠŸèƒ½**ï¼š
- æ¯30åˆ†é’Ÿæ£€æŸ¥`HEARTBEAT.md`æ–‡ä»¶
- è§£æä»»åŠ¡åˆ—è¡¨å¹¶æ‰§è¡Œ
- æ”¯æŒä»»åŠ¡çš„æ·»åŠ ã€åˆ é™¤ã€é‡å†™

**ä»»åŠ¡æ ¼å¼**ï¼š
```markdown
# Heartbeat Tasks

- [ ] Check calendar and remind of upcoming events
- [ ] Scan inbox for urgent emails  
- [ ] Check weather forecast for today
- [x] Completed task (will be ignored)
```

**æ‰§è¡Œæµç¨‹**ï¼š
```python
async def _on_heartbeat(self) -> None:
    """å¤„ç†å¿ƒè·³æ£€æŸ¥"""
    heartbeat_file = self.workspace / "HEARTBEAT.md"
    
    if not heartbeat_file.exists():
        return
    
    content = heartbeat_file.read_text()
    tasks = self._parse_tasks(content)
    
    if tasks:
        # å°†ä»»åŠ¡ä½œä¸ºæ¶ˆæ¯å‘é€ç»™ä»£ç†
        task_message = f"Heartbeat tasks:\n" + "\n".join(f"- {task}" for task in tasks)
        
        # é€šè¿‡ä»£ç†å¾ªç¯å¤„ç†
        await self.agent_loop.process_direct(
            message=task_message,
            session_key="system:heartbeat"
        )
```

---

## æ ¸å¿ƒè°ƒç”¨æµç¨‹

### 1. æ¶ˆæ¯å¤„ç†å®Œæ•´æµç¨‹

```mermaid
sequenceDiagram
    participant User
    participant Channel as Chat Channel
    participant Bus as Message Bus
    participant Agent as Agent Loop
    participant Context as Context Builder
    participant LLM as LLM Provider
    participant Tools as Tool Registry
    participant Session as Session Manager

    User->>Channel: å‘é€æ¶ˆæ¯
    Channel->>Bus: publish_inbound(InboundMessage)
    Bus->>Agent: consume_inbound()
    
    Agent->>Session: get_or_create(session_key)
    Agent->>Context: build_messages(session, content, media)
    Context->>Context: åŠ è½½Bootstrapæ–‡ä»¶
    Context->>Context: åŠ è½½è®°å¿†å’ŒæŠ€èƒ½
    Context->>Agent: è¿”å›å®Œæ•´æ¶ˆæ¯åˆ—è¡¨
    
    loop å·¥å…·è°ƒç”¨å¾ªç¯ (æœ€å¤š20æ¬¡)
        Agent->>LLM: chat(messages, tools, model)
        LLM->>Agent: LLMResponse
        
        alt æœ‰å·¥å…·è°ƒç”¨
            Agent->>Tools: execute(tool_name, arguments)
            Tools->>Agent: å·¥å…·æ‰§è¡Œç»“æœ
            Agent->>Agent: æ·»åŠ å·¥å…·ç»“æœåˆ°æ¶ˆæ¯
        else æ— å·¥å…·è°ƒç”¨
            Agent->>Agent: ç»“æŸå¾ªç¯
        end
    end
    
    Agent->>Session: add_message("assistant", response)
    Agent->>Bus: publish_outbound(OutboundMessage)
    Bus->>Channel: consume_outbound()
    Channel->>User: å‘é€å“åº”
```

### 2. å­ä»£ç†æ‰§è¡Œæµç¨‹

```mermaid
sequenceDiagram
    participant Agent as Main Agent
    participant SubMgr as Subagent Manager
    participant SubAgent as Subagent
    participant Tools as Tool Registry
    participant Bus as Message Bus

    Agent->>SubMgr: spawn(task, label)
    SubMgr->>SubMgr: ç”Ÿæˆsubagent_id
    SubMgr->>SubAgent: åå°å¯åŠ¨_run_subagent()
    SubMgr->>Agent: è¿”å›"Spawned subagent {id}"
    
    par ä¸»ä»£ç†ç»§ç»­å¤„ç†
        Agent->>Agent: ç»§ç»­å…¶ä»–ä»»åŠ¡
    and å­ä»£ç†æ‰§è¡Œ
        SubAgent->>SubAgent: æ„å»ºä¸“ç”¨ç³»ç»Ÿæç¤º
        loop å·¥å…·è°ƒç”¨å¾ªç¯ (æœ€å¤š15æ¬¡)
            SubAgent->>SubAgent: è°ƒç”¨LLM
            alt æœ‰å·¥å…·è°ƒç”¨
                SubAgent->>Tools: execute(tool_name, args)
                Tools->>SubAgent: è¿”å›ç»“æœ
            else æ— å·¥å…·è°ƒç”¨
                SubAgent->>SubAgent: å®Œæˆä»»åŠ¡
            end
        end
        SubAgent->>Bus: publish_inbound(ç³»ç»Ÿå…¬å‘Š)
        Bus->>Agent: æ¥æ”¶å­ä»£ç†å®Œæˆé€šçŸ¥
    end
```

### 3. å®šæ—¶ä»»åŠ¡æ‰§è¡Œæµç¨‹

```mermaid
sequenceDiagram
    participant Cron as Cron Service
    participant Agent as Agent Loop
    participant Bus as Message Bus
    participant Channel as Chat Channel

    loop æ¯åˆ†é’Ÿæ£€æŸ¥
        Cron->>Cron: æ£€æŸ¥åˆ°æœŸä»»åŠ¡
        alt æœ‰åˆ°æœŸä»»åŠ¡
            Cron->>Agent: on_job(job)
            Agent->>Agent: process_direct(job.message)
            Agent->>Cron: è¿”å›å“åº”
            
            alt éœ€è¦æŠ•é€’ç»“æœ
                Cron->>Bus: publish_outbound(ç»“æœæ¶ˆæ¯)
                Bus->>Channel: å‘é€åˆ°æŒ‡å®šé¢‘é“
            end
            
            Cron->>Cron: æ›´æ–°ä»»åŠ¡çŠ¶æ€
            Cron->>Cron: è®¡ç®—ä¸‹æ¬¡æ‰§è¡Œæ—¶é—´
        end
    end
```

### 4. æŠ€èƒ½åŠ è½½æµç¨‹

```mermaid
sequenceDiagram
    participant Context as Context Builder
    participant Skills as Skills Loader
    participant FS as File System

    Context->>Skills: get_always_skills()
    Skills->>Skills: æ‰«ææŠ€èƒ½ç›®å½•
    Skills->>Skills: æ£€æŸ¥æŠ€èƒ½ä¾èµ–
    Skills->>Context: è¿”å›å¯ç”¨æŠ€èƒ½åˆ—è¡¨
    
    Context->>Skills: load_skills_for_context(skill_names)
    loop æ¯ä¸ªæŠ€èƒ½
        Skills->>FS: è¯»å–SKILL.md
        Skills->>Skills: è§£æfrontmatter
        Skills->>Skills: ç§»é™¤frontmatter
        Skills->>Context: è¿”å›æŠ€èƒ½å†…å®¹
    end
    
    Context->>Skills: build_skills_summary()
    Skills->>Context: è¿”å›XMLæ ¼å¼æŠ€èƒ½æ‘˜è¦
```

---

## é…ç½®å’Œéƒ¨ç½²

### 1. é…ç½®æ–‡ä»¶ç»“æ„

#### ä¸»é…ç½®æ–‡ä»¶ (`~/.nanobot/config.json`)

```json
{
  "agents": {
    "defaults": {
      "workspace": "~/.nanobot/workspace",
      "model": "anthropic/claude-opus-4-5",
      "max_tokens": 8192,
      "temperature": 0.7,
      "max_tool_iterations": 20
    }
  },
  "providers": {
    "openrouter": {
      "apiKey": "sk-or-v1-xxx",
      "apiBase": null
    },
    "anthropic": {
      "apiKey": "sk-ant-xxx",
      "apiBase": null
    },
    "openai": {
      "apiKey": "sk-xxx",
      "apiBase": null
    },
    "vllm": {
      "apiKey": "dummy",
      "apiBase": "http://localhost:8000/v1"
    }
  },
  "channels": {
    "telegram": {
      "enabled": true,
      "token": "123456:ABC-DEF1234ghIkl-zyx57W2v1u123ew11",
      "allowFrom": ["123456789", "@username"]
    },
    "whatsapp": {
      "enabled": false,
      "bridgeUrl": "ws://localhost:3001",
      "allowFrom": ["+1234567890"]
    }
  },
  "gateway": {
    "host": "0.0.0.0",
    "port": 18790
  },
  "tools": {
    "web": {
      "search": {
        "apiKey": "BSA_xxx",
        "maxResults": 5
      }
    },
    "exec": {
      "timeout": 60,
      "restrictToWorkspace": false
    }
  }
}
```

#### å·¥ä½œç©ºé—´ç»“æ„ (`~/.nanobot/workspace/`)

```
workspace/
â”œâ”€â”€ AGENTS.md          # ä»£ç†æŒ‡ä»¤å’Œè¡Œä¸ºå‡†åˆ™
â”œâ”€â”€ SOUL.md            # ä»£ç†äººæ ¼å’Œç‰¹æ€§  
â”œâ”€â”€ USER.md            # ç”¨æˆ·ä¿¡æ¯å’Œåå¥½
â”œâ”€â”€ TOOLS.md           # å·¥å…·ä½¿ç”¨è¯´æ˜
â”œâ”€â”€ HEARTBEAT.md       # å‘¨æœŸæ€§ä»»åŠ¡åˆ—è¡¨
â”œâ”€â”€ memory/
â”‚   â”œâ”€â”€ MEMORY.md      # é•¿æœŸè®°å¿†
â”‚   â””â”€â”€ 2024-01-15.md  # æ—¥è®°ç¬”è®°
â””â”€â”€ skills/            # è‡ªå®šä¹‰æŠ€èƒ½
    â””â”€â”€ my-skill/
        â””â”€â”€ SKILL.md
```

### 2. å®‰è£…å’Œåˆå§‹åŒ–

#### ä»æºç å®‰è£…ï¼ˆæ¨èå¼€å‘ï¼‰

```bash
git clone https://github.com/HKUDS/nanobot.git
cd nanobot
pip install -e .
```

#### ä½¿ç”¨uvå®‰è£…ï¼ˆæ¨èç”Ÿäº§ï¼‰

```bash
uv tool install nanobot-ai
```

#### ä»PyPIå®‰è£…

```bash
pip install nanobot-ai
```

#### åˆå§‹åŒ–é…ç½®

```bash
# åˆ›å»ºé…ç½®å’Œå·¥ä½œç©ºé—´
nanobot onboard

# ç¼–è¾‘é…ç½®æ–‡ä»¶
nano ~/.nanobot/config.json
```

### 3. è¿è¡Œæ–¹å¼

#### CLIäº¤äº’æ¨¡å¼

```bash
# äº¤äº’å¼èŠå¤©
nanobot agent

# å•æ¡æ¶ˆæ¯
nanobot agent -m "Hello, how are you?"

# æŒ‡å®šæ¨¡å‹
nanobot agent -m "Explain quantum computing" --model "anthropic/claude-sonnet-4-5"
```

#### ç½‘å…³æ¨¡å¼ï¼ˆå¤šé¢‘é“ï¼‰

```bash
# å¯åŠ¨æ‰€æœ‰å¯ç”¨çš„é¢‘é“
nanobot gateway

# æ£€æŸ¥é¢‘é“çŠ¶æ€
nanobot channels status
```

#### å®šæ—¶ä»»åŠ¡ç®¡ç†

```bash
# æ·»åŠ å®šæ—¶ä»»åŠ¡
nanobot cron add --name "morning-briefing" \
  --message "Generate morning briefing with weather and news" \
  --cron "0 8 * * *" \
  --deliver --to "123456789" --channel "telegram"

# åˆ—å‡ºæ‰€æœ‰ä»»åŠ¡
nanobot cron list

# æ‰‹åŠ¨æ‰§è¡Œä»»åŠ¡
nanobot cron run <job_id>

# åˆ é™¤ä»»åŠ¡
nanobot cron remove <job_id>
```

### 4. Dockeréƒ¨ç½²

#### Dockerfile

```dockerfile
FROM python:3.11-slim

WORKDIR /app

# å®‰è£…ç³»ç»Ÿä¾èµ–
RUN apt-get update && apt-get install -y \
    git \
    curl \
    && rm -rf /var/lib/apt/lists/*

# å¤åˆ¶é¡¹ç›®æ–‡ä»¶
COPY . .

# å®‰è£…Pythonä¾èµ–
RUN pip install -e .

# åˆ›å»ºé…ç½®ç›®å½•
RUN mkdir -p /root/.nanobot

# æš´éœ²ç«¯å£
EXPOSE 18790

# é»˜è®¤å‘½ä»¤
CMD ["nanobot", "gateway"]
```

#### æ„å»ºå’Œè¿è¡Œ

```bash
# æ„å»ºé•œåƒ
docker build -t nanobot .

# åˆå§‹åŒ–é…ç½®ï¼ˆé¦–æ¬¡è¿è¡Œï¼‰
docker run -v ~/.nanobot:/root/.nanobot --rm nanobot onboard

# ç¼–è¾‘é…ç½®
nano ~/.nanobot/config.json

# è¿è¡Œç½‘å…³
docker run -d \
  --name nanobot \
  -v ~/.nanobot:/root/.nanobot \
  -p 18790:18790 \
  nanobot

# æŸ¥çœ‹æ—¥å¿—
docker logs -f nanobot
```

#### Docker Compose

```yaml
version: '3.8'

services:
  nanobot:
    build: .
    container_name: nanobot
    ports:
      - "18790:18790"
    volumes:
      - ~/.nanobot:/root/.nanobot
    environment:
      - PYTHONUNBUFFERED=1
    restart: unless-stopped
    
  # WhatsAppæ¡¥æ¥æœåŠ¡ï¼ˆå¯é€‰ï¼‰
  whatsapp-bridge:
    build: ./bridge
    container_name: nanobot-whatsapp-bridge
    ports:
      - "3001:3001"
    volumes:
      - ./bridge/sessions:/app/sessions
    restart: unless-stopped
```

### 5. æœ¬åœ°æ¨¡å‹æ”¯æŒ

#### vLLMéƒ¨ç½²

```bash
# å®‰è£…vLLM
pip install vllm

# å¯åŠ¨æ¨¡å‹æœåŠ¡
vllm serve meta-llama/Llama-3.1-8B-Instruct \
  --host 0.0.0.0 \
  --port 8000 \
  --api-key dummy

# é…ç½®nanobotä½¿ç”¨æœ¬åœ°æ¨¡å‹
{
  "providers": {
    "vllm": {
      "apiKey": "dummy",
      "apiBase": "http://localhost:8000/v1"
    }
  },
  "agents": {
    "defaults": {
      "model": "meta-llama/Llama-3.1-8B-Instruct"
    }
  }
}
```

#### Ollamaé›†æˆ

```bash
# å¯åŠ¨Ollama
ollama serve

# æ‹‰å–æ¨¡å‹
ollama pull llama3.1:8b

# é…ç½®LiteLLMä»£ç†
{
  "providers": {
    "vllm": {
      "apiKey": "dummy", 
      "apiBase": "http://localhost:11434/v1"
    }
  },
  "agents": {
    "defaults": {
      "model": "llama3.1:8b"
    }
  }
}
```

---

## æ‰©å±•å¼€å‘

### 1. è‡ªå®šä¹‰å·¥å…·å¼€å‘

#### å·¥å…·åŸºç±»

```python
from nanobot.agent.tools.base import Tool
from typing import Any

class MyCustomTool(Tool):
    @property
    def name(self) -> str:
        return "my_tool"
    
    @property 
    def description(self) -> str:
        return "Description of what my tool does"
    
    @property
    def parameters(self) -> dict[str, Any]:
        return {
            "type": "object",
            "properties": {
                "param1": {
                    "type": "string",
                    "description": "First parameter"
                },
                "param2": {
                    "type": "integer", 
                    "description": "Second parameter",
                    "minimum": 0
                }
            },
            "required": ["param1"]
        }
    
    async def execute(self, **kwargs: Any) -> str:
        param1 = kwargs.get("param1")
        param2 = kwargs.get("param2", 0)
        
        # å·¥å…·é€»è¾‘å®ç°
        result = f"Processed {param1} with value {param2}"
        
        return result
```

#### æ³¨å†Œè‡ªå®šä¹‰å·¥å…·

```python
# åœ¨AgentLoopåˆå§‹åŒ–æ—¶æ³¨å†Œ
def _register_custom_tools(self) -> None:
    self.tools.register(MyCustomTool())
    # æ³¨å†Œæ›´å¤šè‡ªå®šä¹‰å·¥å…·...
```

### 2. è‡ªå®šä¹‰æŠ€èƒ½å¼€å‘

#### æŠ€èƒ½æ–‡ä»¶ç»“æ„

```
workspace/skills/my-skill/
â”œâ”€â”€ SKILL.md           # æŠ€èƒ½æè¿°å’Œä½¿ç”¨è¯´æ˜
â”œâ”€â”€ scripts/           # ç›¸å…³è„šæœ¬ï¼ˆå¯é€‰ï¼‰
â”‚   â””â”€â”€ helper.sh
â””â”€â”€ data/              # æ•°æ®æ–‡ä»¶ï¼ˆå¯é€‰ï¼‰
    â””â”€â”€ config.json
```

#### æŠ€èƒ½æ–‡ä»¶æ ¼å¼ (`SKILL.md`)

```markdown
---
description: "Custom skill for specific task"
always: false
metadata: |
  {
    "nanobot": {
      "requires": {
        "bins": ["curl", "jq"],
        "env": ["API_KEY"]
      },
      "always": false
    }
  }
---

# My Custom Skill

This skill helps with specific tasks.

## Usage

Use the `my_tool` to accomplish X:

```bash
my_tool --param1 "value" --param2 123
```

## Examples

- Example 1: Basic usage
- Example 2: Advanced usage

## Dependencies

- curl: For HTTP requests
- jq: For JSON processing
- API_KEY environment variable
```

### 3. è‡ªå®šä¹‰é¢‘é“å¼€å‘

#### é¢‘é“åŸºç±»

```python
from nanobot.channels.base import BaseChannel
from nanobot.bus.events import InboundMessage, OutboundMessage
from nanobot.bus.queue import MessageBus

class MyCustomChannel(BaseChannel):
    def __init__(self, config: dict, bus: MessageBus):
        super().__init__(config, bus)
        self.api_token = config.get("token")
        self.is_running = False
    
    async def start(self) -> None:
        """å¯åŠ¨é¢‘é“æœåŠ¡"""
        self.is_running = True
        
        # å¯åŠ¨æ¶ˆæ¯æ¥æ”¶å¾ªç¯
        while self.is_running:
            try:
                # ä»å¤–éƒ¨æœåŠ¡æ¥æ”¶æ¶ˆæ¯
                message = await self._receive_message()
                
                # è½¬æ¢ä¸ºInboundMessage
                inbound = InboundMessage(
                    channel="mychannel",
                    sender_id=message.user_id,
                    chat_id=message.chat_id,
                    content=message.text,
                    media=message.attachments
                )
                
                # å‘é€åˆ°æ¶ˆæ¯æ€»çº¿
                await self.bus.publish_inbound(inbound)
                
            except Exception as e:
                logger.error(f"Error in channel: {e}")
    
    async def stop(self) -> None:
        """åœæ­¢é¢‘é“æœåŠ¡"""
        self.is_running = False
    
    async def send(self, message: OutboundMessage) -> None:
        """å‘é€æ¶ˆæ¯åˆ°å¤–éƒ¨æœåŠ¡"""
        await self._send_to_external_service(
            chat_id=message.chat_id,
            content=message.content,
            media=message.media
        )
    
    async def _receive_message(self):
        """ä»å¤–éƒ¨æœåŠ¡æ¥æ”¶æ¶ˆæ¯ï¼ˆéœ€è¦å®ç°ï¼‰"""
        pass
    
    async def _send_to_external_service(self, chat_id: str, content: str, media: list):
        """å‘é€åˆ°å¤–éƒ¨æœåŠ¡ï¼ˆéœ€è¦å®ç°ï¼‰"""
        pass
```

### 4. è‡ªå®šä¹‰LLMæä¾›å•†

#### æä¾›å•†åŸºç±»

```python
from nanobot.providers.base import LLMProvider, LLMResponse, ToolCallRequest
from typing import Any

class MyLLMProvider(LLMProvider):
    def __init__(self, api_key: str, api_base: str | None = None):
        super().__init__(api_key, api_base)
        self.client = MyLLMClient(api_key, api_base)
    
    async def chat(
        self,
        messages: list[dict[str, Any]],
        tools: list[dict[str, Any]] | None = None,
        model: str | None = None,
        max_tokens: int = 4096,
        temperature: float = 0.7,
    ) -> LLMResponse:
        """è°ƒç”¨è‡ªå®šä¹‰LLMæœåŠ¡"""
        
        # è½¬æ¢æ¶ˆæ¯æ ¼å¼
        formatted_messages = self._format_messages(messages)
        
        # è°ƒç”¨API
        response = await self.client.chat_completion(
            messages=formatted_messages,
            tools=tools,
            model=model or "my-default-model",
            max_tokens=max_tokens,
            temperature=temperature
        )
        
        # è§£æå“åº”
        return self._parse_response(response)
    
    def _format_messages(self, messages: list[dict]) -> list[dict]:
        """è½¬æ¢æ¶ˆæ¯æ ¼å¼ä»¥é€‚é…è‡ªå®šä¹‰API"""
        # å®ç°æ ¼å¼è½¬æ¢é€»è¾‘
        return messages
    
    def _parse_response(self, response: Any) -> LLMResponse:
        """è§£æAPIå“åº”"""
        tool_calls = []
        if response.get("tool_calls"):
            for tc in response["tool_calls"]:
                tool_calls.append(ToolCallRequest(
                    id=tc["id"],
                    name=tc["function"]["name"],
                    arguments=tc["function"]["arguments"]
                ))
        
        return LLMResponse(
            content=response.get("content", ""),
            tool_calls=tool_calls,
            finish_reason=response.get("finish_reason", "stop"),
            usage=response.get("usage", {})
        )
    
    def get_default_model(self) -> str:
        return "my-default-model"
```

---

## æœ€ä½³å®è·µ

### 1. æ€§èƒ½ä¼˜åŒ–

#### æ¶ˆæ¯å¤„ç†ä¼˜åŒ–
- ä½¿ç”¨å¼‚æ­¥å¤„ç†é¿å…é˜»å¡
- åˆç†è®¾ç½®å·¥å…·è°ƒç”¨è¿­ä»£æ¬¡æ•°é™åˆ¶
- å®ç°æ¶ˆæ¯é˜Ÿåˆ—ç¼“å†²æœºåˆ¶

#### å†…å­˜ç®¡ç†
- å®šæœŸæ¸…ç†ä¼šè¯ç¼“å­˜
- é™åˆ¶è®°å¿†æ–‡ä»¶å¤§å°
- ä½¿ç”¨æµå¼å¤„ç†å¤§æ–‡ä»¶

#### å¹¶å‘æ§åˆ¶
```python
# é™åˆ¶å¹¶å‘ä»£ç†å®ä¾‹
semaphore = asyncio.Semaphore(5)

async def process_with_limit(message):
    async with semaphore:
        return await agent_loop.process_message(message)
```

### 2. å®‰å…¨è€ƒè™‘

#### Shellå‘½ä»¤å®‰å…¨
```python
# å±é™©å‘½ä»¤é»‘åå•
DANGEROUS_COMMANDS = [
    "rm -rf", "format", "dd if=", "shutdown", 
    "reboot", "halt", "init 0", "init 6",
    ":(){ :|:& };:", "chmod -R 777 /"
]

def is_safe_command(command: str) -> bool:
    return not any(dangerous in command.lower() for dangerous in DANGEROUS_COMMANDS)
```

#### æ–‡ä»¶è®¿é—®æ§åˆ¶
```python
def is_safe_path(path: str, workspace: Path) -> bool:
    """æ£€æŸ¥è·¯å¾„æ˜¯å¦åœ¨å·¥ä½œç©ºé—´å†…"""
    try:
        resolved = Path(path).resolve()
        workspace_resolved = workspace.resolve()
        return resolved.is_relative_to(workspace_resolved)
    except:
        return False
```

#### APIå¯†é’¥ä¿æŠ¤
- ä½¿ç”¨ç¯å¢ƒå˜é‡å­˜å‚¨æ•æ„Ÿä¿¡æ¯
- å®ç°å¯†é’¥è½®æ¢æœºåˆ¶
- è®°å½•APIè°ƒç”¨å®¡è®¡æ—¥å¿—

### 3. ç›‘æ§å’Œæ—¥å¿—

#### ç»“æ„åŒ–æ—¥å¿—
```python
from loguru import logger

# é…ç½®æ—¥å¿—æ ¼å¼
logger.add(
    "logs/nanobot.log",
    format="{time:YYYY-MM-DD HH:mm:ss} | {level} | {name}:{function}:{line} | {message}",
    rotation="1 day",
    retention="30 days",
    level="INFO"
)

# ä½¿ç”¨ç»“æ„åŒ–æ—¥å¿—
logger.info("Message processed", 
    session_key=session.key,
    message_length=len(message.content),
    tool_calls=len(response.tool_calls),
    processing_time=processing_time
)
```

#### æ€§èƒ½ç›‘æ§
```python
import time
from functools import wraps

def monitor_performance(func):
    @wraps(func)
    async def wrapper(*args, **kwargs):
        start_time = time.time()
        try:
            result = await func(*args, **kwargs)
            duration = time.time() - start_time
            logger.info(f"{func.__name__} completed in {duration:.2f}s")
            return result
        except Exception as e:
            duration = time.time() - start_time
            logger.error(f"{func.__name__} failed after {duration:.2f}s: {e}")
            raise
    return wrapper
```

### 4. æµ‹è¯•ç­–ç•¥

#### å•å…ƒæµ‹è¯•
```python
import pytest
from nanobot.agent.tools.filesystem import ReadFileTool

@pytest.mark.asyncio
async def test_read_file_tool():
    tool = ReadFileTool()
    
    # æµ‹è¯•å‚æ•°éªŒè¯
    errors = tool.validate_params({"path": "/test/file.txt"})
    assert len(errors) == 0
    
    # æµ‹è¯•æ‰§è¡Œï¼ˆéœ€è¦mockæ–‡ä»¶ç³»ç»Ÿï¼‰
    with patch("pathlib.Path.read_text") as mock_read:
        mock_read.return_value = "test content"
        result = await tool.execute(path="/test/file.txt")
        assert "test content" in result
```

#### é›†æˆæµ‹è¯•
```python
@pytest.mark.asyncio
async def test_agent_message_flow():
    # åˆ›å»ºæµ‹è¯•é…ç½®
    config = Config()
    bus = MessageBus()
    provider = MockLLMProvider()
    
    # åˆ›å»ºä»£ç†å¾ªç¯
    agent = AgentLoop(bus, provider, workspace=Path("/tmp/test"))
    
    # å‘é€æµ‹è¯•æ¶ˆæ¯
    message = InboundMessage(
        channel="test",
        sender_id="user1", 
        chat_id="chat1",
        content="Hello"
    )
    
    await bus.publish_inbound(message)
    
    # éªŒè¯å“åº”
    response = await bus.consume_outbound()
    assert response.content is not None
    assert response.channel == "test"
```

### 5. éƒ¨ç½²å’Œè¿ç»´

#### å¥åº·æ£€æŸ¥
```python
from fastapi import FastAPI

app = FastAPI()

@app.get("/health")
async def health_check():
    return {
        "status": "healthy",
        "timestamp": datetime.now().isoformat(),
        "version": __version__,
        "channels": channel_manager.get_status(),
        "cron_jobs": cron_service.status()
    }
```

#### ä¼˜é›…å…³é—­
```python
import signal
import asyncio

class GracefulShutdown:
    def __init__(self):
        self.shutdown = False
        signal.signal(signal.SIGINT, self._signal_handler)
        signal.signal(signal.SIGTERM, self._signal_handler)
    
    def _signal_handler(self, signum, frame):
        logger.info(f"Received signal {signum}, initiating graceful shutdown...")
        self.shutdown = True
    
    async def wait_for_shutdown(self):
        while not self.shutdown:
            await asyncio.sleep(0.1)
```

#### é…ç½®çƒ­é‡è½½
```python
import watchdog.events
import watchdog.observers

class ConfigWatcher(watchdog.events.FileSystemEventHandler):
    def __init__(self, config_path: Path, reload_callback):
        self.config_path = config_path
        self.reload_callback = reload_callback
    
    def on_modified(self, event):
        if event.src_path == str(self.config_path):
            logger.info("Config file changed, reloading...")
            asyncio.create_task(self.reload_callback())
```

---

## æ•…éšœæ’é™¤

### 1. å¸¸è§é—®é¢˜

#### LLMè°ƒç”¨å¤±è´¥
```python
# æ£€æŸ¥APIå¯†é’¥é…ç½®
if not os.environ.get("OPENROUTER_API_KEY"):
    logger.error("Missing OpenRouter API key")

# æ£€æŸ¥æ¨¡å‹åç§°æ ¼å¼
if not model.startswith("openrouter/"):
    model = f"openrouter/{model}"

# å®ç°é‡è¯•æœºåˆ¶
@retry(stop=stop_after_attempt(3), wait=wait_exponential(multiplier=1, min=4, max=10))
async def call_llm_with_retry(messages, tools):
    return await provider.chat(messages=messages, tools=tools)
```

#### å·¥å…·æ‰§è¡Œè¶…æ—¶
```python
# è®¾ç½®åˆç†çš„è¶…æ—¶æ—¶é—´
async def execute_with_timeout(tool_func, timeout=60):
    try:
        return await asyncio.wait_for(tool_func(), timeout=timeout)
    except asyncio.TimeoutError:
        return f"Tool execution timed out after {timeout}s"
```

#### å†…å­˜æ³„æ¼
```python
# å®šæœŸæ¸…ç†ä¼šè¯ç¼“å­˜
async def cleanup_sessions(session_manager):
    while True:
        await asyncio.sleep(3600)  # æ¯å°æ—¶æ¸…ç†ä¸€æ¬¡
        session_manager.cleanup_old_sessions(max_age_hours=24)
```

### 2. è°ƒè¯•æŠ€å·§

#### å¯ç”¨è¯¦ç»†æ—¥å¿—
```python
# è®¾ç½®æ—¥å¿—çº§åˆ«
logger.remove()
logger.add(sys.stderr, level="DEBUG")

# è®°å½•LLMè°ƒç”¨è¯¦æƒ…
logger.debug("LLM Request", 
    model=model,
    message_count=len(messages),
    tool_count=len(tools) if tools else 0
)
```

#### æ¶ˆæ¯æµè·Ÿè¸ª
```python
# ä¸ºæ¯ä¸ªæ¶ˆæ¯æ·»åŠ è·Ÿè¸ªID
import uuid

class TrackedMessage:
    def __init__(self, original_message):
        self.trace_id = str(uuid.uuid4())[:8]
        self.original = original_message
        logger.info(f"[{self.trace_id}] Message received: {original_message.content[:50]}...")
```

#### æ€§èƒ½åˆ†æ
```python
import cProfile
import pstats

def profile_agent_loop():
    profiler = cProfile.Profile()
    profiler.enable()
    
    # è¿è¡Œä»£ç†å¾ªç¯
    asyncio.run(agent_loop.start())
    
    profiler.disable()
    stats = pstats.Stats(profiler)
    stats.sort_stats('cumulative')
    stats.print_stats(20)
```

---

## æ€»ç»“

nanobotæ˜¯ä¸€ä¸ªè®¾è®¡ç²¾è‰¯çš„è½»é‡çº§AIåŠ©æ‰‹æ¡†æ¶ï¼Œé€šè¿‡ä»¥ä¸‹å…³é”®ç‰¹æ€§å®ç°äº†å¼ºå¤§çš„åŠŸèƒ½ï¼š

1. **æ¨¡å—åŒ–æ¶æ„**ï¼šæ¸…æ™°çš„èŒè´£åˆ†ç¦»ï¼Œæ˜“äºç†è§£å’Œæ‰©å±•
2. **å¼‚æ­¥è®¾è®¡**ï¼šé«˜æ€§èƒ½çš„å¹¶å‘å¤„ç†èƒ½åŠ›
3. **è§£è€¦é€šä¿¡**ï¼šæ¶ˆæ¯æ€»çº¿å®ç°ç»„ä»¶é—´çš„æ¾è€¦åˆ
4. **çµæ´»é…ç½®**ï¼šæ”¯æŒå¤šç§LLMæä¾›å•†å’Œéƒ¨ç½²æ–¹å¼
5. **ä¸°å¯Œç”Ÿæ€**ï¼šå·¥å…·ç³»ç»Ÿã€æŠ€èƒ½ç³»ç»Ÿã€é¢‘é“é›†æˆç­‰

è¯¥æ¡†æ¶ç‰¹åˆ«é€‚åˆï¼š
- AIç ”ç©¶å’Œå®éªŒ
- ä¸ªäººåŠ©æ‰‹å¼€å‘
- ä¼ä¸šå†…éƒ¨å·¥å…·é›†æˆ
- æ•™å­¦å’Œå­¦ä¹ AIä»£ç†å¼€å‘

é€šè¿‡æœ¬æ–‡æ¡£çš„è¯¦ç»†è¯´æ˜ï¼Œå¼€å‘è€…å¯ä»¥å¿«é€Ÿç†è§£nanobotçš„æ¶æ„è®¾è®¡ï¼ŒæŒæ¡æ ¸å¿ƒæ¦‚å¿µï¼Œå¹¶æ ¹æ®éœ€è¦è¿›è¡Œå®šåˆ¶å’Œæ‰©å±•ã€‚